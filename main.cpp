#include <iostream>
#include <iomanip>
#include <string>
#include <cstring>
using namespace std;
/***********************************************************************
* Program:
*    Lab 068, Vulnerabilities & Exploits
*    Brother Helfrich, CS 370
* Author:
*    John Miller
*    Bretton Steiner
*    Ben Smith
*    Tyler Starr
*    Jed Billman
*
* Summary:
*    Enter a brief description of your program here!
 ************************************************************************/

void safe() { cout << "Safe\n"; }
void dangerous() { cout << "Dangerous\n"; }
/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(long index)//index input, not sanatized
{
    bool permissions = false;//item being attacked.
    long testArray[10];//an array
    testArray[index] = -1;//ffffffff will be "true". 
                          //This is the code that will inject true into permissions
    cout << endl;
    if(permissions)//exploit test
        cout << "Vulnerability exploited.\n";
    else
        cout << "Used as intended.\n";
    
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
    cout << "\tArray Working:";
    arrayVulnerability(3);//Call with input 3
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
    cout << "\tArray Exploit:";
    arrayVulnerability(11);//call with input 11 which is out of bounds
}



/*************************************
 * ARC INJECTION VULNERABILITY
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for
 *    user input to overwrite the function pointer. This
 *    typically happens through a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer
 *    must be dereferenced.
 ****************************************/
void arcVulnerability(long input[], int size)
{
   long number[2];
   void (*p)() = safe; //1

   for (int i = 0; i < size; i++)
   {
      number[i] = input[i]; //2
   }

   p(); //3
}

/**************************************
 * ARC INJECTION WORKING
 *************************************/
void arcWorking()
{
   cout << "\tArc Working:\n";
   long number[2] = {12345, 67890};
   arcVulnerability(number, sizeof(number)/sizeof(number[0]));
}

/**************************************
 * ARC INJECTION EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the function pointer.
 * 2. The attacker must have the address to another function
 *    which is to be used to replace the existing function
 *    pointer.
 *************************************/
void arcExploit()
{
   cout << "\tArc Exploit:\n";
   long exploit[3];
   exploit[0] = 12345;
   exploit[1] = 67890;
   exploit[2] = (long)dangerous;

   arcVulnerability(exploit, sizeof(exploit)/sizeof(exploit[0]));
}


/**************************************
 * VTABLE VULNERABILITY
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for
 *    user input to overwrite parts of the V-Table.
 * 4. After a virtual function pointer is overwritten, the
 *    virtual function must be called.
 *************************************/
class Vulnerability
{
public:
   long buffer[2];
   virtual void authorize() {}
};

class Authorization : public Vulnerability
{
public:
   void authorize() { cout << "Not authorized\n"; }
   void obtain_credentials() { cout << "Authorized!\n"; }
};

/**************************************
 * VTABLE WORKING
 *************************************/
void vtableWorking()
{
   Authorization obj;
   obj.authorize();
}

/**************************************
 * VTABLE EXPLOIT
 * 1. Through some vulnerability, the V-Table pointer or
 *    a function pointer within the V-Table must be
 *    overwritten.
 * 2. The attacker must have the address to another V-Table
 *    pointer or a function pointer.
 *************************************/
void vtableExploit()
{
   Authorization obj;

   obj.buffer[0] = 0;

   cout << '[' << setw(2) << 'i' << ']'
        << setw(15) << "address"
        << setw(20) << "hexadecimal"
        << setw(20) << "points"
        << endl;
   cout << "----+"
        << "---------------+"
        << "-------------------+"
        << "-------------------+"
        << "-----------------+\n";

   for (long i = 16; i >= -8; i--)
   {
      ////////////////////////////////////////////////
      // Insert code here to display the callstack
      void* offset = (void*)(&obj.buffer) + i * 8;
      cout << '[' << setw(2) << i << ']'
           << setw(15) << offset
           << setw(20) << showbase << hex << *(long*)offset
           << setw(20) << showbase << hex << (*(long*)offset < 0x4000 ? 0 : *(*(long**)offset))
           << dec << endl;
      //
      ////////////////////////////////////////////////
   }

   cout << "Safe: " << (void*)(&obj.authorize) << '\n';
   cout << "Dangerous: " << (void*)(&obj.obtain_credentials) << '\n';

   cout << "Buffer: " << (void*)(&obj.buffer) << '\n';

   obj.authorize();
}



/*************************************
 * STACK SMASHING VULNERABILITY
 * 1. There must be a buffer (such as an array) on the stack.
 * 2. The buffer must be reachable from an external input.
 * 3. The mechanism to fill the buffer from the external
 *    input must not correctly check for the buffer size.
 * 4. The buffer must be overrun (extend beyond the intended
 *    limits of the array).
 ****************************************/
void stackVulnerability(char *input)
{
	char var[18];
	strcpy(var, input);
}

/**************************************
 * STACK SMASHING WORKING
 *************************************/
void stackWorking()
{
  	char str[] = "testing";
   	stackVulnerability(str);
}

/**************************************
 * STACK SMASHING EXPLOIT
 * 1. The attacker must provide more data into the outwardly
 *    facing buffer than the buffer is designed to hold.
 * 2. The attacker must know where the stack pointer resides
 *    on the stack. Thsi should be just beyond the end of
 *    the buffer.
 * 3. The attacker must insert machine language instructions
 *    in the buffer. This may occur before, after, or even
 *    around the stack pointer. The machine language could
 *    be already compiled code in the program.
 * 4. The attacker must overwrite the stack pointer. The old
 *    value, directing the flow of the program after the
 *    function is returned, must be changed from the calling
 *    function to the provided machine language in step 3.
 *************************************/
void stackExploit()
{
      	char str[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAA";

   	/*Run on g++ (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0
   	*** stack smashing detected ***: <unknown> terminated
	Aborted (core dumped)*/
	//stackVulnerability(str);
}



/*************************************
 * HEAP SPRAYING VULNERABILITY
 * 1. There must be two adjacent heap buffers
 * 2. The first buffer must be reachable through external input
 * 3. Must not check correctly for buffer size
 * 4. The second buffer must be released before the first
 ****************************************/
void heapVulnerability(char* input)
{
   char* p1 = new char[8]; //1
   char* p2 = new char[8];

   strcpy(p2, "Safe");
   strcpy(p1, input); //2
                      //3 input not checked for correct size

   cout << "p2: " << p2 << '\n';

   delete[] p2; //4

   delete[] p1;
}

/**************************************
 * HEAP SPRAYING WORKING
 *************************************/
void heapWorking()
{
   heapVulnerability("Good");
}

/**************************************
 * HEAP SPRAYING EXPLOIT
 * 1. The attacker must provide more data into the outwardly
 *    facing heap buffer than the buffer is desinged to hold.
 * 2. The attacker must know the layout of the Memory Control
 *    Block (MCB) (essencially a linked list) residing just
 *    after the buffer.
 * 3. The attacker must provide a new MCB containing both the
 *    location of the memory overwrite and the new data to be
 *    overwritten.
 *************************************/
void heapExploit()
{
   // The AAAs will go into the p1 allocation.
   // The hhhs will overwrite the MCB.
   // The 123s overwrite the p2 allocation.
   
   /* This code causes a segfault, indicating it
   worked correctly. Since the program cannot continue
   afterwards, I have commented it out. */
   //heapVulnerability("AAAAAAAAhhhhhhhh1234567890");
}



/*************************************
 * INTEGER UNDERFLOW VULNERABILITY
 * 1. There must be a security check represented by an
 *    expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the
 *    sentinel must be reachable through external input.
 *    This sentinel is a variable used to make the security
 *    decision from the first requirement.
 ****************************************/
void intVulnerability(int aggressionChange)//Allows for number input
{
    //Recreating a famous int underflow error from the Civilization games
    unsigned int gandhiAggression;//Number with potential to overflow. 
    gandhiAggression = 10;
    gandhiAggression += aggressionChange;//directly used user input
    //lack of sanatization leaves the uint exploitable
  
    if(gandhiAggression < 255)
        cout << "Gandhi is a chill guy, your Civilisation shall live. Aggression level: "
             << gandhiAggression << "(No Exploit)\n";
    else if(gandhiAggression < 1000)
        cout << "Gandhi is angry with you, your Civilisation is now at war. Aggression level: "
             << gandhiAggression << "(No Exploit)\n";
    else
        cout << "Gandhi went berserk and launched nukes at you. Aggression level: "
             << gandhiAggression << "(Exploited!)\n";

   
}

/**************************************
 * INTEGER OVERFLOW WORKING
 *************************************/
void intWorking()
{
   intVulnerability(10);
}

/**************************************
 * INTEGER OVERFLOW EXPLOIT
 * 1. Provide input, either a buffer size or a single value,
 *    that is directly or indirectly used in the vulnerable
 *    expression.
 * 2. The input must exceed the valid bounds of the data-type
 *    resulting in an overflow or underflow condition.
 *************************************/
void intExploit()
{
   intVulnerability(-11);
}

string displayCharArray(const char * p)
{
   string output;
   for (int i = 0; i < 8; i++)
       output += string(" ") + (p[i] >= ' ' && p[i] <= 'z' ? p[i] : '.');
   return output;
}

void copyUnicodeText(short* src, short* dest, int size)
{
   for (int i = 0; i < size; i++)
   {
      dest[i] = src[i];
   }
}

string displayUnicode(short* str)
{
   string result;
   for (int i = 0; str[i]; i++)
   {
      result += (char)str[i];
   }
   return result;
}

/*************************************
 * ANSI-UNICODE VULNERABILITY
 * 1. There must be a buffer where the basetype is greater
 *    than one.
 * 2. Validation of the buffer must check the size of the
 *    buffer rather than the number of elements in the
 *    buffer.
 ****************************************/
void ansiVulnerability(short* input)
{
   // We are using short to simulate unicode.
   short name[16]; // This has a size of 32, not 16
   short adminPrivileges = 0;

   copyUnicodeText(input, name, sizeof(name));

   if (adminPrivileges == 0)
   {
      cout << "Hello " << displayUnicode(name) << ". You are not an admin.\n";
   }
   else
   {
      cout << "Welcome, " << displayUnicode(name) << "! You are an admin!\n";
   }
}

/**************************************
 * ANSI-UNICODE WORKING
 *************************************/
void ansiWorking()
{
    cout << "AnsiWorking:\n";
    short input[16];
    char name[] = "Tyler";

    int i;
    for (i = 0; name[i]; i++)
      input[i] = (short)name[i];
    input[i] = '\0'; // add null since the above loop stops at null

    ansiVulnerability(input);
}

/**************************************
 * ANSI-UNICODE EXPLOIT
 *************************************/
void ansiExploit()
{
    cout << "AnsiExploit:\n";
    short input[32];
    char name[] = "BBBBBBBBBBBBBBBBzzzzzzzzzzzzzzzz";

    int i;
    for (i = 0; name[i]; i++)
      input[i] = (short)name[i];
    input[i] = '\0'; // add null since the above loop stops at null

    ansiVulnerability(input);
}


/***********************************************************************
* Function:
*    main()
* Inputs: none
* Summary:
*    Driver function for the program.
 ************************************************************************/
int main()
{
   cout << "Array exploit:\n";
   arrayWorking();
   arrayExploit();

   cout << "--------------------\nArc injection exploit:\n";
   arcWorking();
   arcExploit();

   cout << "--------------------\nVTable exploit:\n";
   vtableWorking();
   vtableExploit();

   cout << "--------------------\nStack exploit:\n";
   stackWorking();
   stackExploit();

   cout << "--------------------\nHeap exploit:\n";
   heapWorking();
   heapExploit();

   cout << "--------------------\nInteger overflow exploit:\n";
   intWorking();
   intExploit();

   cout << "--------------------\nAnsi-Unicode exploit:\n";
   ansiWorking();
   ansiExploit();

  return 0;
}	
